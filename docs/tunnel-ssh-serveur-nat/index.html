<!doctype html>
<html lang="fr">
<head>
	<title>Utiliser SSH pour exposer un serveur derri√®re un NAT - yoannlr, notes d&#39;un admin sys</title>
	<meta charset="utf-8">
    
        
            <meta name="keywords" content="tunnel, ssh, cloudflare tunnel, tcp, udp, autossh, robuste, resilient, automatique, nat, forwarding, transfert, remote">
            <meta name="description" content="SSH permet d&#39;utiliser un VPS comme interm√©diaire pour exposer une machine de votre LAN sur Internet">
        
    
    <meta name="author" content="yoannlr">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="icon" type="image/x-icon" href="https://avatars.githubusercontent.com/u/32494673">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<header>
	<h1><a href="/">yoannlr:~$</a></h1>
	<p>notes d&apos;un admin sys</p>
	<nav>
		<p>
			<a href="https://github.com/yoannlr">GitHub</a>
			<a href="/cheatsheet">Cheatsheets</a>
		</p>
	</nav>
</header>
<main><article>
	<h1 id="utiliser-ssh-pour-exposer-un-serveur-derri√®re-un-nat">Utiliser SSH pour exposer un serveur derri√®re un NAT</h1>
<p>√Ä l&rsquo;aide d&rsquo;un petit VPS et de rien de plus que SSH, il est possible d&rsquo;exposer une machine derri√®re un NAT ou dans un LAN sans devoir configurer un mapping de port (aka &ldquo;ouvrir les ports de la box&rdquo;).
La manip&rsquo; consiste √† initier un tunnel SSH depuis la machine que l&rsquo;on souhaite exposer sur internet, vers le VPS qui dispose d&rsquo;une adresse IP publique.
Ensuite, sur le VPS, il suffit d&rsquo;ouvrir un socket et de rediriger le traffic dans le tunnel.
Excellente nouvelle : openssh fait tout cela de mani√®re transparente, en une commande.</p>
<p>Depuis la machine que l&rsquo;on souhaite exposer :</p>
<pre tabindex="0"><code>ssh -R 0.0.0.0:1234:localhost:1234 tunneluser@vps
</code></pre><p>Cette commande ouvre un tunnel de notre machine locale port 1234 vers un socket cr√©√© automatiquement sur le VPS port 1234, √† l&rsquo;√©coute de toutes les adresses.</p>
<div class="notice">
<p><strong>Important !</strong> Pour pouvoir √©couter sur toutes les adresses (dont 0.0.0.0), il faut d&rsquo;abord configurer l&rsquo;option <code>GatewayPorts</code> du daemon SSH du VPS :</p>
<p><code>/etc/ssh/sshd_config</code> :</p>
<pre tabindex="0"><code>GatewayPorts clientspecified
</code></pre><p>Puis <code>systemctl restart ssh</code></p>

</div>

<p>Pour que ssh ne lance pas de shell et se contente de g√©rer le tunnel, on peut ajouter l&rsquo;option <code>-N</code> √† la commande.
Si on souhaite ex√©cuter le tunnel en arri√®re plan, on peut aussi rajouter l&rsquo;option <code>-f</code>.</p>
<pre tabindex="0"><code>ssh -Nf -R 0.0.0.0:1234:localhost:1234 tunneluser@vps
</code></pre><p>L&rsquo;avantage principal, selon moi, de cette manipulation, est de louer un petit VPS comme point d&rsquo;entr√©e vers un gros serveur qu&rsquo;on auto-h√©berge.
On peut utiliser n&rsquo;importe quel protocole bas√© sur TCP.</p>
<h3 id="un-exemple">Un exemple</h3>
<p>Un exemple pour rendre publiquement accessible un serveur Minecraft (port 25565 par d√©faut) h√©berg√© sur son propre LAN :</p>
<pre tabindex="0"><code>ssh -Nf -R 0.0.0.0:25565:localhost:25565 tunneluser@vps
</code></pre><p>Les clients indiqueront alors qu&rsquo;il souhaitent se connecter au VPS, mais le VPS ne servira que d&rsquo;interm√©diaire entre eux et la machine du LAN.</p>
<p>J&rsquo;ai test√© cette solution et la latence est tout √† fait acceptable : 40ms avec une box fibre optique et un VPS lou√© chez un h√©bergeur bien connu.</p>
<h2 id="s√©curisation-c√¥t√©-vps">S√©curisation c√¥t√© VPS</h2>
<p>Pour limiter les risques, je vous recommande de cr√©er un utilisateur d√©di√© au tunnel, avec <code>/bin/true</code> comme shell :</p>
<pre tabindex="0"><code>useradd -m -s /bin/true tunneluser
</code></pre><p>Malgr√© cette configuration, notre <code>tunneluser</code> peut toujours sp√©cifier une commande √† lancer (<code>ssh tunneluser@vps ls /</code> par exemple).</p>
<p>On va donc configurer le daemon SSH pour vraiment restreindre <code>tunneluser</code>.</p>
<p>√âdition de <code>/etc/ssh/sshd_config</code> :</p>
<pre tabindex="0"><code>Match User tunneluser
	X11Forwarding no
	AllowAgentForwarding no
	PermitTTY no
	AllowTcpForwarding yes
</code></pre><p>Puis <code>systemctl restart ssh</code></p>
<h2 id="cl√©-ssh">Cl√© SSH</h2>
<p>La n√©cessit√© de saisir un mot de passe √† la connexion SSH emp√™che d&rsquo;ouvrir le tunnel automatiquement (avec un service par exemple).
Pour r√©soudre ce probl√®me, on va g√©n√©rer une cl√© SSH pour notre <code>tunneluser</code>.</p>
<pre tabindex="0"><code>ssh-keygen -f tunneluser_rsa -t rsa -b 4096
</code></pre><p>Puis copier la cl√© sur son compte, sur le VPS (d&rsquo;o√π la n√©cessit√© de lui avoir cr√©√© un homedir).</p>
<pre tabindex="0"><code>ssh-copy-id -i tunneluser_rsa.pub tunneluser@vps
</code></pre><h2 id="r√©silience-aux-pannes">R√©silience aux pannes</h2>
<p>Plusieurs options SSH sont int√©ressantes pour d√©tecter les pannes r√©seau et rouvrir le tunnel d√®s le r√©tablissement.</p>
<p>Dans <code>man ssh_config</code> (options c√¥t√© client) :</p>
<ul>
<li>
<p>l&rsquo;option <code>ServerAliveInterval</code> permet d&rsquo;envoyer des paquets pour tester la connexion √† intervalle r√©gulier (d√©fini en secondes)</p>
</li>
<li>
<p>l&rsquo;option <code>ServerAliveCountMax</code> d√©finit le nombre de paquets sans r√©ponse tol√©r√© avant de consid√©rer que la connexion a timeout et de rendre la main</p>
</li>
<li>
<p>l&rsquo;option <code>ExitOnForwardFailure</code> (d√©finir √† yes) rend la main si le tunnel ne s&rsquo;est pas ouvert correctement</p>
</li>
</ul>
<p>Ces options nous donnent la commande suivante, plus robuste, que l&rsquo;on pourrait ex√©ctuer dans une boucle pour toujours rouvrir le tunnel :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ssh -N -o ServerAliveInterval=10 -o ServerAliveCountMax=3 -o ExitOnForwardFailure=yes -R 0.0.0.0:1234:localhost:1234 tunneluser@vps
</span></span></code></pre></div><p>Avec ces options, le client SSH rendra la main au bout de 30 secondes d&rsquo;incident r√©seau (3 √ó 10 secondes) ou si la connexion SSH s&rsquo;est bien pass√©e mais pas l&rsquo;ouverture du tunnel.</p>
<p>On peut aussi s&rsquo;int√©resser aux options c√¥t√© serveur (<code>man sshd_config</code>) :</p>
<ul>
<li>
<p>les options <code>ClientAliveInterval</code> et <code>ClientAliveCountMax</code>, m√©canisme √©quivalent c√¥t√© serveur.
On peut les d√©finir aux m√™mes valeurs que c√¥t√© client.</p>
</li>
<li>
<p>l&rsquo;option <code>StreamLocalBindUnlink</code> (d√©finir √† yes) s&rsquo;assure que les sockets &ldquo;zombies&rdquo; ouverts par des tunnels pr√©c√©dents sont nettoy√©s avant de cr√©er des nouveaux sockets.
√áa permet d&rsquo;√©viter des erreurs &ldquo;cannot listen on port 1234&rdquo; car un socket existe toujours !</p>
<p>Si vous n&rsquo;aviez pas activ√© cette option et que des sockets &ldquo;zombies&rdquo; vous bloquent, utilisez <code>ss</code> pour les fermer : <code>ss --kill state close-wait src :1234</code></p>
</li>
</ul>
<p>Ces trois derni√®res options sont √† d√©finir dans <code>/etc/ssh/sshd_config</code>.</p>
<p>C√¥t√© client, on peut imaginer un script similaire √† celui-ci pour un tunnel r√©silient aux incidents r√©seau :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#00f">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span><span style="color:#00f">while</span> true; <span style="color:#00f">do</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#a31515">&#34;opening tunnel&#34;</span>
</span></span><span style="display:flex;"><span>    ssh -N -o ServerAliveInterval=10 -o ServerAliveCountMax=3 -o ExitOnForwardFailure=yes -R 0.0.0.0:1234:localhost:1234 tunneluser@vps
</span></span><span style="display:flex;"><span>    echo <span style="color:#a31515">&#34;tunnel closed, trying again in 20 seconds&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">done</span>
</span></span></code></pre></div><h2 id="et-pour-le-traffic-udp-">Et pour le traffic UDP ?</h2>
<p>Cette m√©thode est limit√©e √† l&rsquo;ouverture de tunnels TCP.
Des hacks bas√©s sur <code>socat</code> ou <code>netcat</code> existent pour faire transiter les datagrammes UDP dans des paquets TCP, mais la nature totalement diff√©rente des protocoles n&rsquo;offre aucune garantie quand √† la fiabilit√© de ces m√©thodes.</p>
<p>L&rsquo;outil <a href="https://securesocketfunneling.github.io/ssf/#home">ssf</a> r√©pond au besoin, avec une latence plus importante (140 ms dans le m√™me contexte).</p>
<p>üëâ Mon article sur le sujet : <a href="/tunnel-udp-ssf">Cr√©er un tunnel UDP pour avec SSF (Secure Socket Funneling) pour exposer un service derri√®re un NAT</a></p>

	<p class="art-date" id="art-date">Publi&eacute; le 5 juin 2025</p>
	<p class="back-home"><a href="/">Retour &agrave; l&apos;index</a></p>
	
		
		
		
	
	<script type="text/javascript">
		let xhr = new XMLHttpRequest();
		xhr.open("GET", "https://abacus.jasoncameron.dev/hit/yoannlr.github.io/tunnel-ssh-serveur-nat");
		xhr.responseType = "json";
		xhr.onload = function() {
			count = this.response.value;
			document.getElementById("art-date").innerHTML += ", <span title=\"Compt&eacute; avec Abacus, une API libre et open-source\">consult&eacute; " + count + " fois</span>";
		}
		xhr.send();
	</script>
		
	
</article>
</main>
<footer>
	<p>Appr&eacute;ciez la simplicit&eacute; de ce site...</p>
	<p class="rss"><a href="/index.xml">Flux RSS</a></p>
</footer>
</body>
</html>
